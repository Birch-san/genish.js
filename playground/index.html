<html>
  <head>
    <title>Genish.js Playground</title>
    <script src="../node_modules/codemirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="../node_modules/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="../node_modules/codemirror/theme/monokai.css">
    <script src="../node_modules/codemirror/mode/javascript/javascript.js"></script>
    <script src="../dist/gen.lib.js"></script>
<style>
.CodeMirror-highlight {
  background:red
}
body { margin: 0 }

#editor { width:45%; box-sizing: border; display:inline-block; height:100%; border-right:1px solid #666  }
#console {width:55%; box-sizing:border; float:right; display:inline-block; top:0; background:grey; position:absolute; height:100% }

</style>

  </head>

  <body>
    <div id='editor'></div>
    <div id='console'></div>
  
  </body>
  <script>
    var cm, cmconsole, exampleCode, AudioContext = AudioContext || webkitAudioContext,
        isStereo = false

    window.onload = function() {
      cm = CodeMirror( document.querySelector('#editor'), {
        mode:   'javascript',
        value:  exampleCode,
        keyMap: 'playground',
        autofocus: true,
        theme:'monokai'
      })

      cm.setSize( null, '100%' )

      cmconsole = CodeMirror( document.querySelector('#console'), {
        mode:'javascript',
        value:'// genish playground, v0.0.1: https://github.com/charlieroberts/genish.js',
        readOnly:'nocursor',
        theme:'monokai'
      })     
      
      cmconsole.setSize( null, '100%' )
      genish.export( window )
    }
    
    var ctx = new AudioContext(),
        node = ctx.createScriptProcessor( 2048, 0, 2 ),
        clear = function() { return 0 },
        fnc  = clear,
        play = function( graph, debug ) {
          if( debug === undefined ) debug = false
          
          isStereo = Array.isArray( graph )

          fnc = gen.createCallback( graph, debug )
          cmconsole.setValue( fnc.toString() )
        }

    node.onaudioprocess = function( audioProcessingEvent ) {
      var outputBuffer = audioProcessingEvent.outputBuffer;

      var left = outputBuffer.getChannelData( 0 ),
          right= outputBuffer.getChannelData( 1 )

      for (var sample = 0; sample < left.length; sample++) {
        if( !isStereo ) {
          left[ sample ] = right[ sample ] = fnc();
        }else{
          let out = fnc()
          left[ sample ] = out[0]
          right[ sample] = out[1]
        }
      }
    }
    
    node.connect( ctx.destination )

    CodeMirror.keyMap.playground =  {
      fallthrough:'default',

      'Ctrl-Enter'( cm ) {
        try {
          var selectedCode = getSelectionCodeColumn( cm, false )

            flash( cm, selectedCode.selection )

            var func = new Function( selectedCode.code )

            func()
        } catch (e) {
          console.log( e )
        }
      },
      'Alt-Enter'( cm ) {
        try {
          var selectedCode = getSelectionCodeColumn( cm, true )

            flash( cm, selectedCode.selection )

            var func = new Function( selectedCode.code )
            func()
        } catch (e) {
          console.log( e )
        }
      },
      'Ctrl-.'( cm ) {
        fnc = clear
        cmconsole.setValue('// silencio.\n' + fnc.toString() )
        console.log( 'silencio.' )
      },
    }

    var getSelectionCodeColumn = function( cm, findBlock ) {
      var pos = cm.getCursor(), 
          text = null

      if( !findBlock ) {
        text = cm.getDoc().getSelection()

          if ( text === "") {
            text = cm.getLine( pos.line )
          }else{
            pos = { start: cm.getCursor('start'), end: cm.getCursor('end') }
            //pos = null
          }
      }else{
        var startline = pos.line, 
          endline = pos.line,
          pos1, pos2, sel

            while ( startline > 0 && cm.getLine( startline ) !== "" ) { startline-- }
        while ( endline < cm.lineCount() && cm.getLine( endline ) !== "" ) { endline++ }

        pos1 = { line: startline, ch: 0 }
        pos2 = { line: endline, ch: 0 }

        text = cm.getRange( pos1, pos2 )

          pos = { start: pos1, end: pos2 }
      }

      if( pos.start === undefined ) {
        var lineNumber = pos.line,
          start = 0,
          end = text.length

            pos = { start:{ line:lineNumber, ch:start }, end:{ line:lineNumber, ch: end } }
      }

      return { selection: pos, code: text }
    }

    var flash = function(cm, pos) {
      var sel,
          cb = function() { sel.clear() }

      if (pos !== null) {
        if( pos.start ) { // if called from a findBlock keymap
          sel = cm.markText( pos.start, pos.end, { className:"CodeMirror-highlight" } );
        }else{ // called with single line
          sel = cm.markText( { line: pos.line, ch:0 }, { line: pos.line, ch:null }, { className: "CodeMirror-highlight" } )
        }
      }else{ // called with selected block
        sel = cm.markText( cm.getCursor(true), cm.getCursor(false), { className: "CodeMirror-highlight" } );
      }

      window.setTimeout(cb, 250);
    }
    
    exampleCode = 
`/*
To execute code: 
  a. execute selected block: hit Ctrl+Enter
  b. execute one line: place cursor on line and hit Ctrl+Enter
  c. execute block: place cursor in block and hit Alt+Enter

Most examples are formatted so that they can be executed as a
single block; just place your cursor inside of them and hit
Alt+Enter.

To clear audio graph and stop sound: Ctrl+. (Ctrl+Period)

To run an arbitrary genish graph, wrap it in a call to
the play() function

Available ugens: add,sub, mul, div, abs, round, sin, accum, cycle, peek, 
phasor, data, ssd (single-sample delay), delta,
param (although param doesn't work with play()),
ceil, max, min, floor, sign, sin, cos, tan, asin, acos, atan, poke,
wrap, clamp, delay

Only one graph can be played at a time in this playground.
*/

/****** non-band-limited saw *******/
saw = mul( phasor(330), .05 )
play( saw )

/****** sine oscillator (no wavetable) *******/

graph = sin( 
  mul( 
    accum( mul( 440, 1/44100 ) ), 
    Math.PI * 2 
  )
)
play( graph )

/****** amplitude modulation *******/

graph = mul( 
  cycle(440), 
  add( 
    .1, 
    mul( cycle(4), .1 ) 
  ) 
)
play( graph )

/****** frequency modulation *******/

lfo = mul( cycle(4), .5 )
ramp = mul( phasor(.1), 200 )
rampedLFO = mul( lfo, ramp )
 
graph = cycle( add( 440, rampedLFO ) )
 
play( graph )

/******** stereo sound ***********/

mod = mul( phasor(.1), 800 )
p  = mul( cycle( add( 400, mod  ) ), sub(1,phasor(8) ) )
p2 = mul( cycle( sub( 1200, mod ) ), sub(1,phasor(5) ) )
 
// by passing an array to play we provide a left and a right channel,
// in this instance both of them are using the phasor named 'mod', which
// is memoized to avoid extra computation
play( [ p, p2 ] )

/****** (LOUD + noisy) frequency modulation using feedback ******/

// ssd is equivalent to history in gen~, a single-sample delay
// (the history name is used by the window object in js...)
// an argument to ssd sets its initial value
sampler = ssd(.001) 
 
//here we record the output of a sawtooth wave into our ssd each sampel,
//and then use this value on the next sample to modulate its frequency
graph = sampler.record( phasor( mul( 3000, sampler ) ) )
 
play( graph )

/****** using data with peek (defaults to linear interpolation) *******/

d = data( [440,880,220,330] )
 
graph = cycle( peek( d, phasor(.1) ) )
 
play( graph )

/******* using data w/ peek (no interpolation) ******/

d = data( [220,330,440,880] )

// create a ramp from 1-4 over 10 seconds
acceleration = mul( phasor(.1), 4 )
 
graph = cycle( 
  peek( d, phasor( acceleration ), { interp:'none' } ) 
)
 
play( graph )

/******** notes w/ delay ***********/

frequencies = data( [220,330,440,880] )
 
freqSignal = peek( frequencies, phasor( .5 ), { interp:'none' } ) 
 
envelope = sub( 1, phasor(2) )
 
notes = mul( cycle( freqSignal ), envelope )
 
gain = mul( notes, .1 )
 
echo = delay( gain, 11025, { size: 22050 })
 
play( add( gain, echo ) )

/****** 150 sine oscillators *******/
 
oscillators = []
numOscillators = 150
 
for( var i = 0; i < numOscillators; i++ ) {
  oscillators.push( 
    mul( cycle( 100 + i *20 ), 1/numOscillators ) 
  )
}
 
play( add.apply(null, oscillators) )

`
  </script>
</html>
